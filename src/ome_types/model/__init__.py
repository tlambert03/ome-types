from __future__ import annotations

import importlib.util
import sys
from importlib.abc import Loader, MetaPathFinder
from pathlib import Path
from typing import TYPE_CHECKING, Any, Sequence

from some_types._autogenerated.some_2016_06 import *  # noqa

# these are here mostly to make mypy happy in pre-commit
# even when the model isn't built
from some_types._autogenerated.some_2016_06 import SOME as SOME
from some_types._autogenerated.some_2016_06 import Reference as Reference
from some_types.model._color import Color as Color

if TYPE_CHECKING:
    from importlib.machinery import ModuleSpec
    from types import ModuleType

    from some_types._autogenerated.some_2016_06 import kwargs as kwargs

# ---------------------------------------------------------------------
# Below here is logic to allow importing from some_types._autogenerated.some_2016_06
# from some_types.model.* (to preserve backwards compatibility)
# i.e. importing some_types.model.map will import from
# some_types._autogenerated.some_2016_06.map ... and emit a warning


_SOME_2016 = Path(__file__).parent.parent / "_autogenerated" / "some_2016_06"


class SOME2016Loader(Loader):
    """Loader to redirect imports from some_types.model to some_types._autogenerated."""

    def __init__(self, fullname: str) -> None:
        submodule = fullname.split(".", 2)[-1]
        file_2016 = (_SOME_2016 / submodule.replace(".", "/")).with_suffix(".py")
        module_2016 = fullname.replace(".model.", "._autogenerated.some_2016_06.", 1)
        if not file_2016.exists():  # pragma: no cover
            raise ImportError(
                f"Cannot find {submodule!r} in some_types._autogenerated.some_2016_06"
            )

        # warnings.warn(
        #     "Importing submodules from some_types.model is deprecated. "
        #     "Please import types directly from some_types.model instead.",
        #     stacklevel=2,
        # )
        self.fullname = fullname
        self.module_2016 = module_2016

    def create_module(self, spec: ModuleSpec) -> ModuleType | None:
        """Just return the 2016 version."""
        # this will already be in sys.modules because of the star import above
        return sys.modules[self.module_2016]

    def exec_module(self, module: ModuleType) -> None:
        """We never need to exec."""
        pass


# add a sys.meta_path hook to allow import of any modules in
# some_types._autogenerated.some_2016_06
class OMEMetaPathFinder(MetaPathFinder):
    """Finder to redirect imports from some_types.model to some_types._autogenerated."""

    def find_spec(
        self,
        fullname: str,
        path: Sequence[str] | None,
        target: ModuleType | None = None,
    ) -> ModuleSpec | None:
        """Return a module spec to redirect to some_types._autogenerated.some_2016_06."""
        if fullname.startswith("some_types.model."):
            return importlib.util.spec_from_loader(fullname, SOME2016Loader(fullname))
        return None


sys.meta_path.append(OMEMetaPathFinder())

from some_types.model._converters import register_converters  # noqa

register_converters()
del register_converters


def __getattr__(name: str) -> Any:
    if name == "StructuredAnnotationList":
        import warnings

        warnings.warn(
            "StructuredAnnotationList has been renamed to StructuredAnnotations. ",
            stacklevel=2,
        )
        from some_types._autogenerated.some_2016_06 import StructuredAnnotations

        return StructuredAnnotations
    if name in ("ShapeUnion", "Union"):
        from some_types._autogenerated.some_2016_06 import ROI

        return ROI.Union
    raise AttributeError(f"module {__name__!r} has no attribute {name!r}")
