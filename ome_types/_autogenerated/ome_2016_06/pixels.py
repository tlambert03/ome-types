from typing import Optional

from pydantic import Field, model_validator

from ome_types._autogenerated.ome_2016_06.bin_data import BinData
from ome_types._autogenerated.ome_2016_06.channel import Channel
from ome_types._autogenerated.ome_2016_06.metadata_only import MetadataOnly
from ome_types._autogenerated.ome_2016_06.pixel_type import PixelType
from ome_types._autogenerated.ome_2016_06.pixels_dimension_order import (
    Pixels_DimensionOrder,
)
from ome_types._autogenerated.ome_2016_06.plane import Plane
from ome_types._autogenerated.ome_2016_06.tiff_data import TiffData
from ome_types._autogenerated.ome_2016_06.units_length import UnitsLength
from ome_types._autogenerated.ome_2016_06.units_time import UnitsTime
from ome_types._mixins._base_type import OMEType
from ome_types._mixins._validators import pixels_root_validator

__NAMESPACE__ = "http://www.openmicroscopy.org/Schemas/OME/2016-06"


class Pixels(OMEType):
    """Pixels is going to be removed in the future, but it is still required.

    This is just notice that the contents of Pixels will be moved up to
    Image in a future release. This is because there has only been 1
    Pixels object in each Image for some time. The concept of multiple
    Pixels sets for one Image failed to take off. It is therefore
    redundant. The Image will be unreadable if any of the required Pixel
    attributes are missing. The Pixels themselves can be stored within
    the OME-XML compressed by plane, and encoded in Base64. Or the
    Pixels may be stored in TIFF format. The Pixels element should
    contain a list of BinData or TiffData, each containing a single
    plane of pixels. These Pixels elements, when read in document order,
    must produce a 5-D pixel array of the size specified in this
    element, and in the dimension order specified by 'DimensionOrder'.
    All of the values in the Pixels object when present should match the
    same value stored in any associated TIFF format (e.g. SizeX should
    be the same). Where there is a mismatch our readers will take the
    value from the TIFF structure as overriding the value in the OME-
    XML. This is simply a pragmatic decision as it increases the
    likelihood of reading data from a slightly incorrect file.

    Attributes
    ----------
    channels : list[Channel]
        (The Pixels Channels).
    bin_data_blocks : list[BinData]
        (The Pixels BinDataBlocks).
    tiff_data_blocks : list[TiffData]
        (The Pixels TiffDataBlocks).
    metadata_only : None | MetadataOnly
        (The Pixels MetadataOnly).
    planes : list[Plane]
        (The Pixels Planes).
    id : str
        (The Pixels ID).
    dimension_order : Pixels_DimensionOrder
        The order in which the individual planes of data are interleaved.
    type : PixelType
        The variable type used to represent each pixel in the image.
    significant_bits : None | int
        The number of bits within the type storing each pixel that are significant.
        e.g. you can store 12 bit data within a 16 bit type. This does not reduce
        the storage requirements but can be a useful indicator when processing or
        viewing the image data.
    interleaved : None | bool
        How the channels are arranged within the data block: true if channels are
        stored RGBRGBRGB...; false if channels are stored RRR...GGG...BBB...
    big_endian : None | bool
        This is true if the pixels data was written in BigEndian order. If this
        value is present it should match the value used in BinData or TiffData. If
        it does not a reader should honour the value used in the BinData or
        TiffData. This values is useful for MetadataOnly files and is to allow for
        future storage solutions.
    size_x : int
        Dimensional size of pixel data array [units:none]
    size_y : int
        Dimensional size of pixel data array [units:none]
    size_z : int
        Dimensional size of pixel data array [units:none]
    size_c : int
        Dimensional size of pixel data array [units:none]
    size_t : int
        Dimensional size of pixel data array [units:none]
    physical_size_x : None | float
        Physical size of a pixel. Units are set by PhysicalSizeXUnit.
    physical_size_x_unit : UnitsLength
        The units of the physical size of a pixel - default:microns[µm].
    physical_size_y : None | float
        Physical size of a pixel. Units are set by PhysicalSizeYUnit.
    physical_size_y_unit : UnitsLength
        The units of the physical size of a pixel - default:microns[µm].
    physical_size_z : None | float
        Physical size of a pixel. Units are set by PhysicalSizeZUnit.
    physical_size_z_unit : UnitsLength
        The units of the physical size of a pixel - default:microns[µm].
    time_increment : None | float
        TimeIncrement is used for time series that have a global timing
        specification instead of per-timepoint timing info. For example in a video
        stream. Units are set by TimeIncrementUnit.
    time_increment_unit : UnitsTime
        The units of the TimeIncrement - default:seconds[s].
    """

    class Meta:
        namespace = "http://www.openmicroscopy.org/Schemas/OME/2016-06"

    channels: list[Channel] = Field(
        default_factory=list,
        json_schema_extra={
            "name": "Channel",
            "type": "Element",
        },
    )
    bin_data_blocks: list[BinData] = Field(
        default_factory=list,
        json_schema_extra={
            "name": "BinData",
            "type": "Element",
        },
    )
    tiff_data_blocks: list[TiffData] = Field(
        default_factory=list,
        json_schema_extra={
            "name": "TiffData",
            "type": "Element",
        },
    )
    metadata_only: Optional[MetadataOnly] = Field(
        default=None,
        json_schema_extra={
            "name": "MetadataOnly",
            "type": "Element",
        },
    )
    planes: list[Plane] = Field(
        default_factory=list,
        json_schema_extra={
            "name": "Plane",
            "type": "Element",
        },
    )
    id: str = Field(
        default="__auto_sequence__",
        pattern=r"(urn:lsid:([\w\-\.]+\.[\w\-\.]+)+:Pixels:\S+)|(Pixels:\S+)",
        json_schema_extra={
            "name": "ID",
            "type": "Attribute",
            "required": True,
            "pattern": r"(urn:lsid:([\w\-\.]+\.[\w\-\.]+)+:Pixels:\S+)|(Pixels:\S+)",
        },
    )
    dimension_order: Pixels_DimensionOrder = Field(
        json_schema_extra={
            "name": "DimensionOrder",
            "type": "Attribute",
            "required": True,
        }
    )
    type: PixelType = Field(
        json_schema_extra={
            "name": "Type",
            "type": "Attribute",
            "required": True,
        }
    )
    significant_bits: Optional[int] = Field(
        default=None,
        ge=1,
        json_schema_extra={
            "name": "SignificantBits",
            "type": "Attribute",
            "min_inclusive": 1,
        },
    )
    interleaved: Optional[bool] = Field(
        default=None,
        json_schema_extra={
            "name": "Interleaved",
            "type": "Attribute",
        },
    )
    big_endian: Optional[bool] = Field(
        default=None,
        json_schema_extra={
            "name": "BigEndian",
            "type": "Attribute",
        },
    )
    size_x: int = Field(
        ge=1,
        json_schema_extra={
            "name": "SizeX",
            "type": "Attribute",
            "required": True,
            "min_inclusive": 1,
        },
    )
    size_y: int = Field(
        ge=1,
        json_schema_extra={
            "name": "SizeY",
            "type": "Attribute",
            "required": True,
            "min_inclusive": 1,
        },
    )
    size_z: int = Field(
        ge=1,
        json_schema_extra={
            "name": "SizeZ",
            "type": "Attribute",
            "required": True,
            "min_inclusive": 1,
        },
    )
    size_c: int = Field(
        ge=1,
        json_schema_extra={
            "name": "SizeC",
            "type": "Attribute",
            "required": True,
            "min_inclusive": 1,
        },
    )
    size_t: int = Field(
        ge=1,
        json_schema_extra={
            "name": "SizeT",
            "type": "Attribute",
            "required": True,
            "min_inclusive": 1,
        },
    )
    physical_size_x: Optional[float] = Field(
        default=None,
        gt=0.0,
        json_schema_extra={
            "name": "PhysicalSizeX",
            "type": "Attribute",
            "min_exclusive": 0.0,
        },
    )
    physical_size_x_unit: UnitsLength = Field(
        default=UnitsLength.MICROMETER,
        json_schema_extra={
            "name": "PhysicalSizeXUnit",
            "type": "Attribute",
        },
    )
    physical_size_y: Optional[float] = Field(
        default=None,
        gt=0.0,
        json_schema_extra={
            "name": "PhysicalSizeY",
            "type": "Attribute",
            "min_exclusive": 0.0,
        },
    )
    physical_size_y_unit: UnitsLength = Field(
        default=UnitsLength.MICROMETER,
        json_schema_extra={
            "name": "PhysicalSizeYUnit",
            "type": "Attribute",
        },
    )
    physical_size_z: Optional[float] = Field(
        default=None,
        gt=0.0,
        json_schema_extra={
            "name": "PhysicalSizeZ",
            "type": "Attribute",
            "min_exclusive": 0.0,
        },
    )
    physical_size_z_unit: UnitsLength = Field(
        default=UnitsLength.MICROMETER,
        json_schema_extra={
            "name": "PhysicalSizeZUnit",
            "type": "Attribute",
        },
    )
    time_increment: Optional[float] = Field(
        default=None,
        json_schema_extra={
            "name": "TimeIncrement",
            "type": "Attribute",
        },
    )
    time_increment_unit: UnitsTime = Field(
        default=UnitsTime.SECOND,
        json_schema_extra={
            "name": "TimeIncrementUnit",
            "type": "Attribute",
        },
    )

    _vpix = model_validator(mode="before")(pixels_root_validator)


DimensionOrder = Pixels_DimensionOrder
